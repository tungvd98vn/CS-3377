{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fmodern Courier New;}{\f1\fmodern\fcharset0 Courier New;}{\f2\fnil\fcharset129 Tahoma;}}
{\colortbl ;\red0\green0\blue0;\red48\green127\blue48;\red127\green127\blue27;\red127\green27\blue127;\red27\green127\blue127;\red64\green64\blue127;\red48\green48\blue127;\red127\green64\blue64;\red64\green127\blue64;}
\viewkind4\uc1\pard\f0\fs18 login as: tdv160130\cf1\highlight1 
\par \cf0\highlight0 tdv160130@cs1.utdallas.edu's password:\cf1\highlight1 
\par \cf0\highlight0      \u9484?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9488?\cf1\highlight1 
\par \cf0\highlight0      \u9474?                        \cf2\f1\bullet  MobaXterm 10.5 \bullet  \cf0\f0                          \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474?            \cf3 (SSH client, X-server and networking tools)\cf0              \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474?                                                                    \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474? \u8594? SSH session to \cf4 tdv160130\cf0 @\cf4 cslinux1.utdallas.edu                   \cf0\u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474?\f1    \bullet  SSH compression : \cf2\f0 v\cf0                                             \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474?\f1    \bullet  SSH-browser     : \cf2\f0 v\cf0                                             \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474?\f1    \bullet  X11-forwarding  : \cf2\f0 v\cf0   (remote display is forwarded through SSH) \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474?\f1    \bullet  DISPLAY         : \cf2\f0 v\cf0   (automatically set on remote server)      \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474?                                                                    \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9474? \u8594? For more info, ctrl+click on \cf5\ul help\cf0\ulnone  or visit our \cf5\ul website\cf0\ulnone            \u9474?\cf1\highlight1 
\par \cf0\highlight0      \u9492?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9472?\u9496?\cf1\highlight1 
\par 
\par 
\par \cf0\highlight0                         Department of Computer Science\cf1\highlight1 
\par \cf0\highlight0                         University of Texas at Dallas\cf1\highlight1 
\par 
\par \cf0\highlight0                 Use of UTD Information Systems is subject to\cf1\highlight1 
\par \cf0\highlight0           the UTD Information Security and Acceptable Use Policy.\cf1\highlight1 
\par 
\par \cf0\highlight0   Pursuant to Texas Administrative Code 202:\cf1\highlight1 
\par \cf0\highlight0   (1) Unauthorized use is prohibited;\cf1\highlight1 
\par \cf0\highlight0   (2) Usage may be subject to security testing and monitoring;\cf1\highlight1 
\par \cf0\highlight0   (3) Misuse is subject to criminal prosecution; and\cf1\highlight1 
\par \cf0\highlight0   (4) No expectation of privacy except as otherwise provided by\cf1\highlight1 
\par \cf0\highlight0       applicable privacy laws.\cf1\highlight1 
\par 
\par \cf0\highlight0         If five (5) incorrect passwords are received from your IP address,\cf1\highlight1 
\par \cf0\highlight0       this system will ban your IP address access for twenty-four (24) hours.\cf1\highlight1 
\par 
\par \cf0\highlight0 [[NOTE: If you are a CS Graduate Student, you cannot logon to this server.]]\cf1\highlight1 
\par \cf0\highlight0 [[         All CS Graduate Students should use csgrads1.utdallas.edu      ]]\cf1\highlight1 
\par \cf0\highlight0 Last login: Sun Apr  1 23:56:10 2018 from rrcs-97-77-48-21.sw.biz.rr.com\cf1\highlight1 
\par 
\par \cf0\highlight0                        ***---***---***---***---***---***\cf1\highlight1 
\par \cf0\highlight0                     csgrads1.utdallas.edu - Linux/CentOS 7.3\cf1\highlight1 
\par \cf0\highlight0                  --All CS Graduate Students should use csgrads1--\cf1\highlight1 
\par \cf0\highlight0                       cs1.utdallas.edu - Linux/CentOS 7.3\cf1\highlight1 
\par \cf0\highlight0                       cs2.utdallas.edu - Linux/CentOS 7.3\cf1\highlight1 
\par \cf0\highlight0                        ***---***---***---***---***---***\cf1\highlight1 
\par 
\par \cf0\highlight0 This system is for use by CS students who need a general purpose Linux system\cf1\highlight1 
\par \cf0\highlight0 to complete homework assignments.  Computationally or resource intensive\cf1\highlight1 
\par \cf0\highlight0 simulations will be throttled automatically.\cf1\highlight1 
\par 
\par \cf0\highlight0 Thank you,\cf1\highlight1 
\par \cf0\highlight0 CS Lab Manager\cf1\highlight1 
\par \cf0\highlight0 cs-labs@utdallas.edu\cf1\highlight1 
\par 
\par \cf0\highlight0                /scratch disk space can be used for temporary files.\cf1\highlight1 
\par \cf0\highlight0             All files will be erased on a regular basis (Sunday 0300).\cf1\highlight1 
\par 
\par \cf0\highlight0 Sourcing /usr/local/etc/skel/global/profile\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~\} ls\cf1\highlight1 
\par \cf6\highlight0 a2\cf0       \cf6 a3\cf0   \cf6 ansda\cf0     \cf7\highlight2 cs3377\cf0\highlight0    \cf6 cs33777\cf0      hello    \cf6 Mail\cf0    \cf6 part2\cf0   \cf6 public_html\cf0   \cf8 src.3e.tar\cf0   \cf6 w12\cf0    \cf6 w4a3\cf0   \cf6 w6\cf0   \cf6 w8\cf0   \cf6 workspace\cf1\highlight1 
\par \cf6\highlight0 a2demo\cf0   \cf6 a4\cf0   \cf6 apue.3e\cf0   \cf6 cs33771\cf0   entry-file  hello.c  \cf6 make1\cf0   \cf6 perl5\cf0   \cf6 S\cf0             \cf6 tunvu\cf0        \cf6 w4a2\cf0   \cf6 w5\cf0     \cf6 w7\cf0   \cf6 w9\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~\} mkdir w13\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~\} cd w13\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf0\highlight0 client.c  conServerThread.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} gcc client.c -o client.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf9\highlight0 client.c\cf0   conServerThread.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} rm client.c\cf1\highlight1 
\par \cf0\highlight0\f1 rm: remove regular file \lquote client.c\rquote ? y\cf1\highlight1\f0 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf0\highlight0 conServerThread.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf0\highlight0 client.c  conServerThread.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} gcc client.c -o client\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf9\highlight0 client\cf0   client.c  conServerThread.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ./client\cf1\highlight1 
\par \cf0\highlight0 Usage: TCPClient <Server IP> <Server Port>: Success\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ./client 10111 129.110.92.115\cf1\highlight1 
\par \cf0\highlight0 Usage: TCPClient <Server IP> <Server Port>: Success\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} g++ client1.c -o client1\cf1\highlight1 
\par \cf0\highlight0\b client1.c:9:30:\b0  \cf8 error: \cf0\f1 ISO C++ forbids declaration of \lquote\b\f0 intmain\b0\f1\rquote  with no type [-fpermissive]\cf1\highlight1\f0 
\par \cf0\highlight0  intmain(int argc, char **argv)\cf1\highlight1 
\par \cf9\highlight0                               ^\cf1\highlight1 
\par \cf0\highlight0\b client1.c:\b0\f1  In function \lquote\b\f0 int intmain(int, char**)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b client1.c:32:33:\b0  \cf8 error: \cf0\f1 invalid conversion from \lquote\b\f0 char*\b0\f1\rquote  to \lquote\b\f0 uint16_t \{aka short unsigned int\}\b0\f1\rquote  [-fpermissive]\cf1\highlight1\f0 
\par \cf0\highlight0  servaddr.sin_port = htons(argv[2]);        //Pass 2nd Arguement as Port Number.\cf1\highlight1 
\par \cf9\highlight0                                  ^\cf1\highlight1 
\par \cf0\highlight0 In file included from \b client1.c:5:0\b0 :\cf1\highlight1 
\par \cf0\highlight0\b /usr/include/netinet/in.h:380:17:\b0  \cf8 error: \cf0\f1   initializing argument 1 of \lquote\b\f0 uint16_t htons(uint16_t)\b0\f1\rquote  [-fpermissive]\cf1\highlight1\f0 
\par \cf0\highlight0  extern uint16_t htons (uint16_t __hostshort)\cf1\highlight1 
\par \cf9\highlight0                  ^\cf1\highlight1 
\par \cf0\highlight0\b client1.c:34:68:\b0  \cf8 error: \cf0\f1 cannot convert \lquote\b\f0 intmain(int, char**)::sockport*\b0\f1\rquote  to \lquote\b\f0 const sockaddr*\b0\f1\rquote  for argument \lquote\b\f0 2\b0\f1\rquote  to \lquote\b\f0 int connect(int, const sockaddr*, socklen_t)\b0\f1\rquote\cf1\highlight1\f0 
\par \cf0\highlight0  if (connect(sockfd, (struct sockport *) &servaddr, sizeof(servaddr))<0)\cf1\highlight1 
\par \cf9\highlight0                                                                     ^\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} vi client1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} g++ client1.c -o client1\cf1\highlight1 
\par \cf0\highlight0\b client1.c:\b0\f1  In function \lquote\b\f0 int main(int, char**)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b client1.c:32:33:\b0  \cf8 error: \cf0\f1 invalid conversion from \lquote\b\f0 char*\b0\f1\rquote  to \lquote\b\f0 uint16_t \{aka short unsigned int\}\b0\f1\rquote  [-fpermissive]\cf1\highlight1\f0 
\par \cf0\highlight0  servaddr.sin_port = htons(argv[2]);        //Pass 2nd Arguement as Port Number.\cf1\highlight1 
\par \cf9\highlight0                                  ^\cf1\highlight1 
\par \cf0\highlight0 In file included from \b client1.c:5:0\b0 :\cf1\highlight1 
\par \cf0\highlight0\b /usr/include/netinet/in.h:380:17:\b0  \cf8 error: \cf0\f1   initializing argument 1 of \lquote\b\f0 uint16_t htons(uint16_t)\b0\f1\rquote  [-fpermissive]\cf1\highlight1\f0 
\par \cf0\highlight0  extern uint16_t htons (uint16_t __hostshort)\cf1\highlight1 
\par \cf9\highlight0                  ^\cf1\highlight1 
\par \cf0\highlight0\b client1.c:34:68:\b0  \cf8 error: \cf0\f1 cannot convert \lquote\b\f0 main(int, char**)::sockport*\b0\f1\rquote  to \lquote\b\f0 const sockaddr*\b0\f1\rquote  for argument \lquote\b\f0 2\b0\f1\rquote  to \lquote\b\f0 int connect(int, const sockaddr*, socklen_t)\b0\f1\rquote\cf1\highlight1\f0 
\par \cf0\highlight0  if (connect(sockfd, (struct sockport *) &servaddr, sizeof(servaddr))<0)\cf1\highlight1 
\par \cf9\highlight0                                                                     ^\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} vi client1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} vi client1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} g++ client1.c -o client1\cf1\highlight1 
\par \cf0\highlight0\b client1.c:\b0\f1  In function \lquote\b\f0 int main(int, char**)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b client1.c:32:39:\b0  \cf8 error: \cf0\f1\lquote\b\f0 arg\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  servaddr.sin_port = htons((int)strtol(arg[2], (char **)NULL, 10));\cf1\highlight1 
\par \cf9\highlight0                                        ^\cf1\highlight1 
\par \cf0\highlight0\b client1.c:35:68:\b0  \cf8 error: \cf0\f1 cannot convert \lquote\b\f0 main(int, char**)::sockport*\b0\f1\rquote  to \lquote\b\f0 const sockaddr*\b0\f1\rquote  for argument \lquote\b\f0 2\b0\f1\rquote  to \lquote\b\f0 int connect(int, const sockaddr*, socklen_t)\b0\f1\rquote\cf1\highlight1\f0 
\par \cf0\highlight0  if (connect(sockfd, (struct sockport *) &servaddr, sizeof(servaddr))<0)\cf1\highlight1 
\par \cf9\highlight0                                                                     ^\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} vi client1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} g++ client1.c -o client1\cf1\highlight1 
\par \cf0\highlight0\b client1.c:\b0\f1  In function \lquote\b\f0 int main(int, char**)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b client1.c:35:68:\b0  \cf8 error: \cf0\f1 cannot convert \lquote\b\f0 main(int, char**)::sockport*\b0\f1\rquote  to \lquote\b\f0 const sockaddr*\b0\f1\rquote  for argument \lquote\b\f0 2\b0\f1\rquote  to \lquote\b\f0 int connect(int, const sockaddr*, socklen_t)\b0\f1\rquote\cf1\highlight1\f0 
\par \cf0\highlight0  if (connect(sockfd, (struct sockport *) &servaddr, sizeof(servaddr))<0)\cf1\highlight1 
\par \cf9\highlight0                                                                     ^\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} vi client1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} cat client1.c\cf1\highlight1 
\par \cf0\highlight0 #include <stdlib.h>\cf1\highlight1 
\par \cf0\highlight0 #include <stdio.h>\cf1\highlight1 
\par \cf0\highlight0 #include <sys/types.h>\cf1\highlight1 
\par \cf0\highlight0 #include <sys/socket.h>\cf1\highlight1 
\par \cf0\highlight0 #include <netinet/in.h>\cf1\highlight1 
\par \cf0\highlight0 #include <string.h>\cf1\highlight1 
\par \cf0\highlight0 #include <arpa/inet.h>\cf1\highlight1 
\par \cf0\highlight0 #define MAXLINE 4096 /*max text line length*/\cf1\highlight1 
\par \cf0\highlight0 int main(int argc, char **argv)\cf1\highlight1 
\par \cf0\highlight0\{\cf1\highlight1 
\par \cf0\highlight0 int sockfd;\cf1\highlight1 
\par \cf0\highlight0 struct sockaddr_in servaddr;\cf1\highlight1 
\par \cf0\highlight0 char sendline[MAXLINE], recvline[MAXLINE];\cf1\highlight1 
\par \cf0\highlight0 // alarm(300); // to terminate after 300 second\cf1\highlight1 
\par \cf0\highlight0 //basic check of the arguments\cf1\highlight1 
\par \cf0\highlight0 //additional checks can be inserted\cf1\highlight1 
\par \cf0\highlight0 if (argc !=2)\cf1\highlight1 
\par \cf0\highlight0\{\cf1\highlight1 
\par \cf0\highlight0 perror("Usage: TCPClient <Server IP> <Server Port>");\cf1\highlight1 
\par \cf0\highlight0 exit(1);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 //Create a socket for the client\cf1\highlight1 
\par \cf0\highlight0 //If sockfd<0 there was an error in the creation of the socket\cf1\highlight1 
\par \cf0\highlight0 if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) <0) \{\cf1\highlight1 
\par \cf0\highlight0 perror("Problem in creating the socket");\cf1\highlight1 
\par \cf0\highlight0 exit(2);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 //Creation of the socket\cf1\highlight1 
\par \cf0\highlight0 memset(&servaddr, 0, sizeof(servaddr));\cf1\highlight1 
\par \cf0\highlight0 servaddr.sin_family = AF_INET;\cf1\highlight1 
\par \cf0\highlight0 servaddr.sin_addr.s_addr= inet_addr(argv[1]);   //Pass 1st Arguement as IPAddress.\cf1\highlight1 
\par \cf0\highlight0 servaddr.sin_port = htons((int)strtol(argv[2], (char **)NULL, 10));\cf1\highlight1 
\par \cf0\highlight0 //servaddr.sin_port = htons(argv[2]);        //Pass 2nd Arguement as Port Number.\cf1\highlight1 
\par \cf0\highlight0 //Connection of the client to the socket\cf1\highlight1 
\par \cf0\highlight0 if (connect(sockfd, (struct sockport *) &servaddr, sizeof(servaddr))<0)\cf1\highlight1 
\par \cf0\highlight0\{\cf1\highlight1 
\par \cf0\highlight0 perror("Problem in connecting to the server");\cf1\highlight1 
\par \cf0\highlight0 exit(3);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 while (fgets(sendline, MAXLINE, stdin) != NULL)\cf1\highlight1 
\par \cf0\highlight0\{\cf1\highlight1 
\par \cf0\highlight0     send(sockfd, sendline, strlen(sendline), 0);\cf1\highlight1 
\par \cf0\highlight0    if (recv(sockfd, recvline, MAXLINE,0) == 0)\cf1\highlight1 
\par \cf0\highlight0    \{\cf1\highlight1 
\par \cf0\highlight0         //error: server terminated prematurely\cf1\highlight1 
\par \cf0\highlight0        perror("The server terminated prematurely");\cf1\highlight1 
\par \cf0\highlight0    exit(4);\cf1\highlight1 
\par \cf0\highlight0    \}\cf1\highlight1 
\par \cf0\highlight0    printf("%s", "String received from the server: ");\cf1\highlight1 
\par \cf0\highlight0    fputs(recvline, stdout);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 exit(0);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} lsl\cf1\highlight1 
\par \cf0\highlight0 bash: lsl: command not found...\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf9\highlight0 client\cf0   client1.c  client.c  conServerThread.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf9\highlight0 client\cf0   client1.c  client.c  conServerThread.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} g++ server1.c -o server1\cf1\highlight1 
\par \cf0\highlight0\b server1.c:\b0\f1  In function \lquote\b\f0 void* serverThread(void*)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b server1.c:25:84:\b0  \cf8 error: \cf0\f1\lquote\b\f0 read\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  while ((recievedMsgLen=read(PARMPTR->connectionDesc,messageBuf,sizeof(messageBuf)-1)) > 0)\cf1\highlight1 
\par \cf9\highlight0                                                                                     ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:29:47:\b0  \cf8 error: \cf0\f1\lquote\b\f0 write\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  if (write(PARMPTR->connectionDesc,"GOT IT\\0",7) < 0)\cf1\highlight1 
\par \cf9\highlight0                                                ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:35:30:\b0  \cf8 error: \cf0\f1\lquote\b\f0 close\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  close(PARMPTR->connectionDesc); /* Avoid descriptor leaks */\cf1\highlight1 
\par \cf9\highlight0                               ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:36:13:\b0  \cf8 error: \cf0\f1\lquote\b\f0 free\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  free(PARMPTR); /* And memory leaks */\cf1\highlight1 
\par \cf9\highlight0              ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:\b0\f1  In function \lquote\b\f0 int main(int, const char**)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b server1.c:47:10:\b0  \cf8 error: \cf0\f1\lquote\b\f0 alarm\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  alarm(120); /* Terminate in 120 seconds */\cf1\highlight1 
\par \cf9\highlight0           ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:53:7:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  exit(1);\cf1\highlight1 
\par \cf9\highlight0        ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:60:65:\b0  \cf8 error: \cf0\f1 cannot convert \lquote\b\f0 main(int, const char**)::sin_port*\b0\f1\rquote  to \lquote\b\f0 const sockaddr*\b0\f1\rquote  for argument \lquote\b\f0 2\b0\f1\rquote  to \lquote\b\f0 int bind(int, const sockaddr*, socklen_t)\b0\f1\rquote\cf1\highlight1\f0 
\par \cf0\highlight0  if (bind(listenDesc, (struct sin_port *) &myAddr, sizeof(myAddr)) < 0) \{\cf1\highlight1 
\par \cf9\highlight0                                                                  ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:62:7:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  exit(1);\cf1\highlight1 
\par \cf9\highlight0        ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:69:57:\b0  \cf8 error: \cf0\f1\lquote\b\f0 address\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                          ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:69:79:\b0  \cf8 error: \cf0\f1\lquote\b\f0 addrlen\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                                                ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:69:87:\b0  \cf8 error: \cf0\f1 expected \lquote\b\f0 ;\b0\f1\rquote  before \lquote\b\f0 )\b0\f1\rquote  token\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                                                        ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:71:64:\b0  \cf8 error: \cf0\f1\lquote\b\f0 malloc\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  parmPtr = (struct serverParm *)malloc(sizeof(struct serverParm));\cf1\highlight1 
\par \cf9\highlight0                                                                 ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:76:21:\b0  \cf8 error: \cf0\f1\lquote\b\f0 close\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  close(connectionDesc);\cf1\highlight1 
\par \cf9\highlight0                      ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:78:7:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  exit(1);\cf1\highlight1 
\par \cf9\highlight0        ^\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} vi server1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} g++ server1.c -o server1\cf1\highlight1 
\par \cf0\highlight0\b server1.c:\b0\f1  In function \lquote\b\f0 void* serverThread(void*)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b server1.c:37:13:\b0  \cf8 error: \cf0\f1\lquote\b\f0 free\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  free(PARMPTR); /* And memory leaks */\cf1\highlight1 
\par \cf9\highlight0              ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:\b0\f1  In function \lquote\b\f0 int main(int, const char**)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b server1.c:54:7:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  exit(1);\cf1\highlight1 
\par \cf9\highlight0        ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:61:65:\b0  \cf8 error: \cf0\f1 cannot convert \lquote\b\f0 main(int, const char**)::sin_port*\b0\f1\rquote  to \lquote\b\f0 const sockaddr*\b0\f1\rquote  for argument \lquote\b\f0 2\b0\f1\rquote  to \lquote\b\f0 int bind(int, const sockaddr*, socklen_t)\b0\f1\rquote\cf1\highlight1\f0 
\par \cf0\highlight0  if (bind(listenDesc, (struct sin_port *) &myAddr, sizeof(myAddr)) < 0) \{\cf1\highlight1 
\par \cf9\highlight0                                                                  ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:63:7:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  exit(1);\cf1\highlight1 
\par \cf9\highlight0        ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:70:57:\b0  \cf8 error: \cf0\f1\lquote\b\f0 address\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                          ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:70:79:\b0  \cf8 error: \cf0\f1\lquote\b\f0 addrlen\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                                                ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:70:87:\b0  \cf8 error: \cf0\f1 expected \lquote\b\f0 ;\b0\f1\rquote  before \lquote\b\f0 )\b0\f1\rquote  token\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                                                        ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:72:64:\b0  \cf8 error: \cf0\f1\lquote\b\f0 malloc\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  parmPtr = (struct serverParm *)malloc(sizeof(struct serverParm));\cf1\highlight1 
\par \cf9\highlight0                                                                 ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:79:7:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  exit(1);\cf1\highlight1 
\par \cf9\highlight0        ^\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} vi server1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} g++ server1.c -o server1\cf1\highlight1 
\par \cf0\highlight0\b server1.c:\b0\f1  In function \lquote\b\f0 int main(int, const char**)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b server1.c:62:65:\b0  \cf8 error: \cf0\f1 cannot convert \lquote\b\f0 main(int, const char**)::sin_port*\b0\f1\rquote  to \lquote\b\f0 const sockaddr*\b0\f1\rquote  for argument \lquote\b\f0 2\b0\f1\rquote  to \lquote\b\f0 int bind(int, const sockaddr*, socklen_t)\b0\f1\rquote\cf1\highlight1\f0 
\par \cf0\highlight0  if (bind(listenDesc, (struct sin_port *) &myAddr, sizeof(myAddr)) < 0) \{\cf1\highlight1 
\par \cf9\highlight0                                                                  ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:71:57:\b0  \cf8 error: \cf0\f1\lquote\b\f0 address\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                          ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:71:79:\b0  \cf8 error: \cf0\f1\lquote\b\f0 addrlen\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                                                ^\cf1\highlight1 
\par \cf0\highlight0\b server1.c:71:87:\b0  \cf8 error: \cf0\f1 expected \lquote\b\f0 ;\b0\f1\rquote  before \lquote\b\f0 )\b0\f1\rquote  token\cf1\highlight1\f0 
\par \cf0\highlight0  connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf9\highlight0                                                                                        ^\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf9\highlight0 client\cf0   client1.c  client.c  conServerThread.c  server1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} cat sever1.c\cf1\highlight1 
\par \cf0\highlight0 cat: sever1.c: No such file or directory\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} cat server1.c\cf1\highlight1 
\par \cf0\highlight0 #include <sys/types.h>\cf1\highlight1 
\par \cf0\highlight0 #include <sys/socket.h>\cf1\highlight1 
\par \cf0\highlight0 #include <netinet/in.h>\cf1\highlight1 
\par \cf0\highlight0 #include <stdio.h>\cf1\highlight1 
\par \cf0\highlight0 #include <pthread.h>\cf1\highlight1 
\par \cf0\highlight0 #include <unistd.h>\cf1\highlight1 
\par \cf0\highlight0 #include <stdlib.h>\cf1\highlight1 
\par \cf0\highlight0 #define PORTNUMBER 10010\cf1\highlight1 
\par \cf0\highlight0 struct serverParm\cf1\highlight1 
\par \cf0\highlight0\{\cf1\highlight1 
\par \cf0\highlight0 int connectionDesc;\cf1\highlight1 
\par \cf0\highlight0\};\cf1\highlight1 
\par \cf0\highlight0 void *serverThread(void *parmPtr)\cf1\highlight1 
\par \cf0\highlight0\{\cf1\highlight1 
\par \cf0\highlight0    #define PARMPTR ((struct serverParm *) parmPtr)\cf1\highlight1 
\par \cf0\highlight0 int recievedMsgLen;\cf1\highlight1 
\par \cf0\highlight0 char messageBuf[1025];\cf1\highlight1 
\par \cf0\highlight0 /* Server thread code to deal with message processing */\cf1\highlight1 
\par \cf0\highlight0 printf("DEBUG: connection made, connectionDesc=%d\\n",\cf1\highlight1 
\par \cf0\highlight0 PARMPTR->connectionDesc);\cf1\highlight1 
\par \cf0\highlight0 if (PARMPTR->connectionDesc < 0)\cf1\highlight1 
\par \cf0\highlight0    \{\cf1\highlight1 
\par \cf0\highlight0 printf("Accept failed\\n");\cf1\highlight1 
\par \cf0\highlight0 return(0); /* Exit thread */\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 /* Receive messages from sender... */\cf1\highlight1 
\par \cf0\highlight0 while ((recievedMsgLen=read(PARMPTR->connectionDesc,messageBuf,sizeof(messageBuf)-1)) > 0)\cf1\highlight1 
\par \cf0\highlight0\{\cf1\highlight1 
\par \cf0\highlight0 recievedMsgLen[messageBuf] = '\\0';\cf1\highlight1 
\par \cf0\highlight0 printf("Message: %s\\n",messageBuf);\cf1\highlight1 
\par \cf0\highlight0 if (write(PARMPTR->connectionDesc,"GOT IT\\0",7) < 0)\cf1\highlight1 
\par \cf0\highlight0        \{\cf1\highlight1 
\par \cf0\highlight0 perror("Server: write error");\cf1\highlight1 
\par \cf0\highlight0 return(0);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 close(PARMPTR->connectionDesc); /* Avoid descriptor leaks */\cf1\highlight1 
\par \cf0\highlight0 free(PARMPTR); /* And memory leaks */\cf1\highlight1 
\par \cf0\highlight0 return(0); /* Exit thread */\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 int main (int argc, char const *argv[])\cf1\highlight1 
\par \cf0\highlight0\{\cf1\highlight1 
\par \cf0\highlight0 int listenDesc;\cf1\highlight1 
\par \cf0\highlight0 struct sockaddr_in myAddr;\cf1\highlight1 
\par \cf0\highlight0 struct serverParm *parmPtr;\cf1\highlight1 
\par \cf0\highlight0 int connectionDesc;\cf1\highlight1 
\par \cf0\highlight0 pthread_t threadID;\cf1\highlight1 
\par \cf0\highlight0 /* For testing purposes, make sure process will terminate eventually */\cf1\highlight1 
\par \cf0\highlight0 alarm(120); /* Terminate in 120 seconds */\cf1\highlight1 
\par \cf0\highlight0 /* Create socket from which to read */\cf1\highlight1 
\par 
\par \cf0\highlight0 if ((listenDesc = socket(AF_INET, SOCK_STREAM, 0)) < 0)\cf1\highlight1 
\par \cf0\highlight0    \{\cf1\highlight1 
\par \cf0\highlight0 perror("open error on socket");\cf1\highlight1 
\par \cf0\highlight0 exit(1);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 /* Create "name" of socket */\cf1\highlight1 
\par \cf0\highlight0 myAddr.sin_family = AF_INET;\cf1\highlight1 
\par \cf0\highlight0 myAddr.sin_addr.s_addr = INADDR_ANY;\cf1\highlight1 
\par \cf0\highlight0 myAddr.sin_port = htons(PORTNUMBER);\cf1\highlight1 
\par 
\par \cf0\highlight0 if (bind(listenDesc, (struct sin_port *) &myAddr, sizeof(myAddr)) < 0) \{\cf1\highlight1 
\par \cf0\highlight0 perror("bind error");\cf1\highlight1 
\par \cf0\highlight0 exit(1);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 /* Start accepting connections.... */\cf1\highlight1 
\par \cf0\highlight0 /* Up to 5 requests for connections can be queued... */\cf1\highlight1 
\par \cf0\highlight0 listen(listenDesc,5);\cf1\highlight1 
\par \cf0\highlight0 while (1) /* Do forever */ \{\cf1\highlight1 
\par \cf0\highlight0 /* Wait for a client connection */\cf1\highlight1 
\par \cf0\highlight0 connectionDesc = accept(listenDesc, (struct sockaddr *)&address, (socklen_t*)&addrlen));       //Accept The Arguements of Client.c\cf1\highlight1 
\par \cf0\highlight0 /* Create a thread to actually handle this client */\cf1\highlight1 
\par \cf0\highlight0 parmPtr = (struct serverParm *)malloc(sizeof(struct serverParm));\cf1\highlight1 
\par \cf0\highlight0 parmPtr->connectionDesc = connectionDesc;\cf1\highlight1 
\par \cf0\highlight0 if (pthread_create(&threadID, NULL, serverThread, (void *)parmPtr) != 0)\cf1\highlight1 
\par \cf0\highlight0        \{\cf1\highlight1 
\par \cf0\highlight0 perror("Thread create error");\cf1\highlight1 
\par \cf0\highlight0 close(connectionDesc);\cf1\highlight1 
\par \cf0\highlight0 close(listenDesc);\cf1\highlight1 
\par \cf0\highlight0 exit(1);\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0 printf("Parent ready for another connection\\n");\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0\}\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ls\cf1\highlight1 
\par \cf9\highlight0 client\cf0   client1.c  client.c  conServerThread.c  server1.c\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} g++ conServerThread.c\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:\b0\f1  In function \lquote\b\f0 void* serverThread(void*)\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b conServerThread.c:46:73:\b0  \cf8 error: \cf0\f1\lquote\b\f0 read\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0              read(PARMPTR->connectionDesc,messageBuf,sizeof(messageBuf)-1)) > 0)\cf1\highlight1 
\par \cf9\highlight0                                                                          ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:50:55:\b0  \cf8 error: \cf0\f1\lquote\b\f0 write\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0          if (write(PARMPTR->connectionDesc,"GOT IT\\0",7) < 0) \{\cf1\highlight1 
\par \cf9\highlight0                                                        ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:55:34:\b0  \cf8 error: \cf0\f1\lquote\b\f0 close\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0      close(PARMPTR->connectionDesc);  /* Avoid descriptor leaks */\cf1\highlight1 
\par \cf9\highlight0                                   ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:56:17:\b0  \cf8 error: \cf0\f1\lquote\b\f0 free\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0      free(PARMPTR);                   /* And memory leaks */\cf1\highlight1 
\par \cf9\highlight0                  ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:\b0\f1  In function \lquote\b\f0 int main()\b0\f1\rquote :\cf1\highlight1\f0 
\par \cf0\highlight0\b conServerThread.c:68:14:\b0  \cf8 error: \cf0\f1\lquote\b\f0 alarm\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0      alarm(120);  /* Terminate in 120 seconds */\cf1\highlight1 
\par \cf9\highlight0               ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:73:15:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0          exit(1);\cf1\highlight1 
\par \cf9\highlight0                ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:83:15:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0          exit(1);\cf1\highlight1 
\par \cf9\highlight0                ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:95:72:\b0  \cf8 error: \cf0\f1\lquote\b\f0 malloc\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0          parmPtr = (struct serverParm *)malloc(sizeof(struct serverParm));\cf1\highlight1 
\par \cf9\highlight0                                                                         ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:100:33:\b0  \cf8 error: \cf0\f1\lquote\b\f0 close\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0              close(connectionDesc);\cf1\highlight1 
\par \cf9\highlight0                                  ^\cf1\highlight1 
\par \cf0\highlight0\b conServerThread.c:102:19:\b0  \cf8 error: \cf0\f1\lquote\b\f0 exit\b0\f1\rquote  was not declared in this scope\cf1\highlight1\f0 
\par \cf0\highlight0              exit(1);\cf1\highlight1 
\par \cf9\highlight0                    ^\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\} ./client\cf1\highlight1 
\par \cf0\highlight0 Usage: TCPClient <Server IP> <Server Port>: Success\cf1\highlight1 
\par \cf0\highlight0\{cslinux1:~/w13\}\cf1\highlight1 
\par \pard\cf0\highlight0\f2\fs20 
\par }
 